// Code generated by MockGen. DO NOT EDIT.
// Source: coordinator.go

// Package coordinator is a generated GoMock package.
package coordinator

import (
	context "context"
	reflect "reflect"

	reexec "github.com/elastic/elastic-agent/internal/pkg/agent/application/reexec"
	transpiler "github.com/elastic/elastic-agent/internal/pkg/agent/transpiler"
	config "github.com/elastic/elastic-agent/internal/pkg/config"
	fleetapi "github.com/elastic/elastic-agent/internal/pkg/fleetapi"
	acker "github.com/elastic/elastic-agent/internal/pkg/fleetapi/acker"
	component "github.com/elastic/elastic-agent/pkg/component"
	runtime "github.com/elastic/elastic-agent/pkg/component/runtime"
	gomock "github.com/golang/mock/gomock"
)

// MockReExecManager is a mock of ReExecManager interface.
type MockReExecManager struct {
	ctrl     *gomock.Controller
	recorder *MockReExecManagerMockRecorder
}

// MockReExecManagerMockRecorder is the mock recorder for MockReExecManager.
type MockReExecManagerMockRecorder struct {
	mock *MockReExecManager
}

// NewMockReExecManager creates a new mock instance.
func NewMockReExecManager(ctrl *gomock.Controller) *MockReExecManager {
	mock := &MockReExecManager{ctrl: ctrl}
	mock.recorder = &MockReExecManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReExecManager) EXPECT() *MockReExecManagerMockRecorder {
	return m.recorder
}

// ReExec mocks base method.
func (m *MockReExecManager) ReExec(callback reexec.ShutdownCallbackFn, argOverrides ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{callback}
	for _, a := range argOverrides {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "ReExec", varargs...)
}

// ReExec indicates an expected call of ReExec.
func (mr *MockReExecManagerMockRecorder) ReExec(callback interface{}, argOverrides ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{callback}, argOverrides...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReExec", reflect.TypeOf((*MockReExecManager)(nil).ReExec), varargs...)
}

// MockUpgradeManager is a mock of UpgradeManager interface.
type MockUpgradeManager struct {
	ctrl     *gomock.Controller
	recorder *MockUpgradeManagerMockRecorder
}

// MockUpgradeManagerMockRecorder is the mock recorder for MockUpgradeManager.
type MockUpgradeManagerMockRecorder struct {
	mock *MockUpgradeManager
}

// NewMockUpgradeManager creates a new mock instance.
func NewMockUpgradeManager(ctrl *gomock.Controller) *MockUpgradeManager {
	mock := &MockUpgradeManager{ctrl: ctrl}
	mock.recorder = &MockUpgradeManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpgradeManager) EXPECT() *MockUpgradeManagerMockRecorder {
	return m.recorder
}

// Ack mocks base method.
func (m *MockUpgradeManager) Ack(ctx context.Context, acker acker.Acker) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ack", ctx, acker)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ack indicates an expected call of Ack.
func (mr *MockUpgradeManagerMockRecorder) Ack(ctx, acker interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ack", reflect.TypeOf((*MockUpgradeManager)(nil).Ack), ctx, acker)
}

// Reload mocks base method.
func (m *MockUpgradeManager) Reload(rawConfig *config.Config) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reload", rawConfig)
	ret0, _ := ret[0].(error)
	return ret0
}

// Reload indicates an expected call of Reload.
func (mr *MockUpgradeManagerMockRecorder) Reload(rawConfig interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reload", reflect.TypeOf((*MockUpgradeManager)(nil).Reload), rawConfig)
}

// Upgrade mocks base method.
func (m *MockUpgradeManager) Upgrade(ctx context.Context, version, sourceURI string, action *fleetapi.ActionUpgrade, skipVerifyOverride bool, pgpBytes ...string) (reexec.ShutdownCallbackFn, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, version, sourceURI, action, skipVerifyOverride}
	for _, a := range pgpBytes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Upgrade", varargs...)
	ret0, _ := ret[0].(reexec.ShutdownCallbackFn)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Upgrade indicates an expected call of Upgrade.
func (mr *MockUpgradeManagerMockRecorder) Upgrade(ctx, version, sourceURI, action, skipVerifyOverride interface{}, pgpBytes ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, version, sourceURI, action, skipVerifyOverride}, pgpBytes...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upgrade", reflect.TypeOf((*MockUpgradeManager)(nil).Upgrade), varargs...)
}

// Upgradeable mocks base method.
func (m *MockUpgradeManager) Upgradeable() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upgradeable")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Upgradeable indicates an expected call of Upgradeable.
func (mr *MockUpgradeManagerMockRecorder) Upgradeable() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upgradeable", reflect.TypeOf((*MockUpgradeManager)(nil).Upgradeable))
}

// MockMonitorManager is a mock of MonitorManager interface.
type MockMonitorManager struct {
	ctrl     *gomock.Controller
	recorder *MockMonitorManagerMockRecorder
}

// MockMonitorManagerMockRecorder is the mock recorder for MockMonitorManager.
type MockMonitorManagerMockRecorder struct {
	mock *MockMonitorManager
}

// NewMockMonitorManager creates a new mock instance.
func NewMockMonitorManager(ctrl *gomock.Controller) *MockMonitorManager {
	mock := &MockMonitorManager{ctrl: ctrl}
	mock.recorder = &MockMonitorManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMonitorManager) EXPECT() *MockMonitorManagerMockRecorder {
	return m.recorder
}

// Enabled mocks base method.
func (m *MockMonitorManager) Enabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Enabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Enabled indicates an expected call of Enabled.
func (mr *MockMonitorManagerMockRecorder) Enabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enabled", reflect.TypeOf((*MockMonitorManager)(nil).Enabled))
}

// MonitoringConfig mocks base method.
func (m *MockMonitorManager) MonitoringConfig(arg0 map[string]interface{}, arg1 []component.Component, arg2 map[string]string) (map[string]interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MonitoringConfig", arg0, arg1, arg2)
	ret0, _ := ret[0].(map[string]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MonitoringConfig indicates an expected call of MonitoringConfig.
func (mr *MockMonitorManagerMockRecorder) MonitoringConfig(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MonitoringConfig", reflect.TypeOf((*MockMonitorManager)(nil).MonitoringConfig), arg0, arg1, arg2)
}

// Reload mocks base method.
func (m *MockMonitorManager) Reload(rawConfig *config.Config) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reload", rawConfig)
	ret0, _ := ret[0].(error)
	return ret0
}

// Reload indicates an expected call of Reload.
func (mr *MockMonitorManagerMockRecorder) Reload(rawConfig interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reload", reflect.TypeOf((*MockMonitorManager)(nil).Reload), rawConfig)
}

// MockRunner is a mock of Runner interface.
type MockRunner struct {
	ctrl     *gomock.Controller
	recorder *MockRunnerMockRecorder
}

// MockRunnerMockRecorder is the mock recorder for MockRunner.
type MockRunnerMockRecorder struct {
	mock *MockRunner
}

// NewMockRunner creates a new mock instance.
func NewMockRunner(ctrl *gomock.Controller) *MockRunner {
	mock := &MockRunner{ctrl: ctrl}
	mock.recorder = &MockRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRunner) EXPECT() *MockRunnerMockRecorder {
	return m.recorder
}

// Errors mocks base method.
func (m *MockRunner) Errors() <-chan error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Errors")
	ret0, _ := ret[0].(<-chan error)
	return ret0
}

// Errors indicates an expected call of Errors.
func (mr *MockRunnerMockRecorder) Errors() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errors", reflect.TypeOf((*MockRunner)(nil).Errors))
}

// Run mocks base method.
func (m *MockRunner) Run(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockRunnerMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRunner)(nil).Run), arg0)
}

// MockRuntimeManager is a mock of RuntimeManager interface.
type MockRuntimeManager struct {
	ctrl     *gomock.Controller
	recorder *MockRuntimeManagerMockRecorder
}

// MockRuntimeManagerMockRecorder is the mock recorder for MockRuntimeManager.
type MockRuntimeManagerMockRecorder struct {
	mock *MockRuntimeManager
}

// NewMockRuntimeManager creates a new mock instance.
func NewMockRuntimeManager(ctrl *gomock.Controller) *MockRuntimeManager {
	mock := &MockRuntimeManager{ctrl: ctrl}
	mock.recorder = &MockRuntimeManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuntimeManager) EXPECT() *MockRuntimeManagerMockRecorder {
	return m.recorder
}

// Errors mocks base method.
func (m *MockRuntimeManager) Errors() <-chan error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Errors")
	ret0, _ := ret[0].(<-chan error)
	return ret0
}

// Errors indicates an expected call of Errors.
func (mr *MockRuntimeManagerMockRecorder) Errors() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errors", reflect.TypeOf((*MockRuntimeManager)(nil).Errors))
}

// PerformAction mocks base method.
func (m *MockRuntimeManager) PerformAction(ctx context.Context, comp component.Component, unit component.Unit, name string, params map[string]interface{}) (map[string]interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PerformAction", ctx, comp, unit, name, params)
	ret0, _ := ret[0].(map[string]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PerformAction indicates an expected call of PerformAction.
func (mr *MockRuntimeManagerMockRecorder) PerformAction(ctx, comp, unit, name, params interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PerformAction", reflect.TypeOf((*MockRuntimeManager)(nil).PerformAction), ctx, comp, unit, name, params)
}

// PerformDiagnostics mocks base method.
func (m *MockRuntimeManager) PerformDiagnostics(arg0 context.Context, arg1 ...runtime.ComponentUnitDiagnosticRequest) []runtime.ComponentUnitDiagnostic {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PerformDiagnostics", varargs...)
	ret0, _ := ret[0].([]runtime.ComponentUnitDiagnostic)
	return ret0
}

// PerformDiagnostics indicates an expected call of PerformDiagnostics.
func (mr *MockRuntimeManagerMockRecorder) PerformDiagnostics(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PerformDiagnostics", reflect.TypeOf((*MockRuntimeManager)(nil).PerformDiagnostics), varargs...)
}

// Run mocks base method.
func (m *MockRuntimeManager) Run(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockRuntimeManagerMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockRuntimeManager)(nil).Run), arg0)
}

// State mocks base method.
func (m *MockRuntimeManager) State() []runtime.ComponentComponentState {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "State")
	ret0, _ := ret[0].([]runtime.ComponentComponentState)
	return ret0
}

// State indicates an expected call of State.
func (mr *MockRuntimeManagerMockRecorder) State() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "State", reflect.TypeOf((*MockRuntimeManager)(nil).State))
}

// SubscribeAll mocks base method.
func (m *MockRuntimeManager) SubscribeAll(arg0 context.Context) *runtime.SubscriptionAll {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubscribeAll", arg0)
	ret0, _ := ret[0].(*runtime.SubscriptionAll)
	return ret0
}

// SubscribeAll indicates an expected call of SubscribeAll.
func (mr *MockRuntimeManagerMockRecorder) SubscribeAll(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeAll", reflect.TypeOf((*MockRuntimeManager)(nil).SubscribeAll), arg0)
}

// Update mocks base method.
func (m *MockRuntimeManager) Update(arg0 []component.Component) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockRuntimeManagerMockRecorder) Update(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRuntimeManager)(nil).Update), arg0)
}

// MockConfigChange is a mock of ConfigChange interface.
type MockConfigChange struct {
	ctrl     *gomock.Controller
	recorder *MockConfigChangeMockRecorder
}

// MockConfigChangeMockRecorder is the mock recorder for MockConfigChange.
type MockConfigChangeMockRecorder struct {
	mock *MockConfigChange
}

// NewMockConfigChange creates a new mock instance.
func NewMockConfigChange(ctrl *gomock.Controller) *MockConfigChange {
	mock := &MockConfigChange{ctrl: ctrl}
	mock.recorder = &MockConfigChangeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigChange) EXPECT() *MockConfigChangeMockRecorder {
	return m.recorder
}

// Ack mocks base method.
func (m *MockConfigChange) Ack() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ack")
	ret0, _ := ret[0].(error)
	return ret0
}

// Ack indicates an expected call of Ack.
func (mr *MockConfigChangeMockRecorder) Ack() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ack", reflect.TypeOf((*MockConfigChange)(nil).Ack))
}

// Config mocks base method.
func (m *MockConfigChange) Config() *config.Config {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*config.Config)
	return ret0
}

// Config indicates an expected call of Config.
func (mr *MockConfigChangeMockRecorder) Config() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockConfigChange)(nil).Config))
}

// Fail mocks base method.
func (m *MockConfigChange) Fail(err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Fail", err)
}

// Fail indicates an expected call of Fail.
func (mr *MockConfigChangeMockRecorder) Fail(err interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fail", reflect.TypeOf((*MockConfigChange)(nil).Fail), err)
}

// MockErrorReporter is a mock of ErrorReporter interface.
type MockErrorReporter struct {
	ctrl     *gomock.Controller
	recorder *MockErrorReporterMockRecorder
}

// MockErrorReporterMockRecorder is the mock recorder for MockErrorReporter.
type MockErrorReporterMockRecorder struct {
	mock *MockErrorReporter
}

// NewMockErrorReporter creates a new mock instance.
func NewMockErrorReporter(ctrl *gomock.Controller) *MockErrorReporter {
	mock := &MockErrorReporter{ctrl: ctrl}
	mock.recorder = &MockErrorReporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockErrorReporter) EXPECT() *MockErrorReporterMockRecorder {
	return m.recorder
}

// MockConfigManager is a mock of ConfigManager interface.
type MockConfigManager struct {
	ctrl     *gomock.Controller
	recorder *MockConfigManagerMockRecorder
}

// MockConfigManagerMockRecorder is the mock recorder for MockConfigManager.
type MockConfigManagerMockRecorder struct {
	mock *MockConfigManager
}

// NewMockConfigManager creates a new mock instance.
func NewMockConfigManager(ctrl *gomock.Controller) *MockConfigManager {
	mock := &MockConfigManager{ctrl: ctrl}
	mock.recorder = &MockConfigManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigManager) EXPECT() *MockConfigManagerMockRecorder {
	return m.recorder
}

// ActionErrors mocks base method.
func (m *MockConfigManager) ActionErrors() <-chan error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActionErrors")
	ret0, _ := ret[0].(<-chan error)
	return ret0
}

// ActionErrors indicates an expected call of ActionErrors.
func (mr *MockConfigManagerMockRecorder) ActionErrors() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActionErrors", reflect.TypeOf((*MockConfigManager)(nil).ActionErrors))
}

// Errors mocks base method.
func (m *MockConfigManager) Errors() <-chan error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Errors")
	ret0, _ := ret[0].(<-chan error)
	return ret0
}

// Errors indicates an expected call of Errors.
func (mr *MockConfigManagerMockRecorder) Errors() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errors", reflect.TypeOf((*MockConfigManager)(nil).Errors))
}

// Run mocks base method.
func (m *MockConfigManager) Run(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockConfigManagerMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockConfigManager)(nil).Run), arg0)
}

// Watch mocks base method.
func (m *MockConfigManager) Watch() <-chan ConfigChange {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Watch")
	ret0, _ := ret[0].(<-chan ConfigChange)
	return ret0
}

// Watch indicates an expected call of Watch.
func (mr *MockConfigManagerMockRecorder) Watch() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockConfigManager)(nil).Watch))
}

// MockVarsManager is a mock of VarsManager interface.
type MockVarsManager struct {
	ctrl     *gomock.Controller
	recorder *MockVarsManagerMockRecorder
}

// MockVarsManagerMockRecorder is the mock recorder for MockVarsManager.
type MockVarsManagerMockRecorder struct {
	mock *MockVarsManager
}

// NewMockVarsManager creates a new mock instance.
func NewMockVarsManager(ctrl *gomock.Controller) *MockVarsManager {
	mock := &MockVarsManager{ctrl: ctrl}
	mock.recorder = &MockVarsManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVarsManager) EXPECT() *MockVarsManagerMockRecorder {
	return m.recorder
}

// Errors mocks base method.
func (m *MockVarsManager) Errors() <-chan error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Errors")
	ret0, _ := ret[0].(<-chan error)
	return ret0
}

// Errors indicates an expected call of Errors.
func (mr *MockVarsManagerMockRecorder) Errors() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errors", reflect.TypeOf((*MockVarsManager)(nil).Errors))
}

// Run mocks base method.
func (m *MockVarsManager) Run(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockVarsManagerMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockVarsManager)(nil).Run), arg0)
}

// Watch mocks base method.
func (m *MockVarsManager) Watch() <-chan []*transpiler.Vars {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Watch")
	ret0, _ := ret[0].(<-chan []*transpiler.Vars)
	return ret0
}

// Watch indicates an expected call of Watch.
func (mr *MockVarsManagerMockRecorder) Watch() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockVarsManager)(nil).Watch))
}

// MockStateFetcher is a mock of StateFetcher interface.
type MockStateFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockStateFetcherMockRecorder
}

// MockStateFetcherMockRecorder is the mock recorder for MockStateFetcher.
type MockStateFetcherMockRecorder struct {
	mock *MockStateFetcher
}

// NewMockStateFetcher creates a new mock instance.
func NewMockStateFetcher(ctrl *gomock.Controller) *MockStateFetcher {
	mock := &MockStateFetcher{ctrl: ctrl}
	mock.recorder = &MockStateFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateFetcher) EXPECT() *MockStateFetcherMockRecorder {
	return m.recorder
}

// State mocks base method.
func (m *MockStateFetcher) State(arg0 bool) State {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "State", arg0)
	ret0, _ := ret[0].(State)
	return ret0
}

// State indicates an expected call of State.
func (mr *MockStateFetcherMockRecorder) State(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "State", reflect.TypeOf((*MockStateFetcher)(nil).State), arg0)
}
